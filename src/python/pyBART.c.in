/* Copyright 2018. Damien Nguyen.
 * All rights reserved. Use of this source code is governed by
 * a BSD-style license which can be found in the LICENSE file.
 *
 * Authors:
 * 2018    Damien Nguyen <damien.nguyen@alumni.epfl.ch>
 */

#include <Python.h>
#define PY_ARRAY_UNIQUE_SYMBOL bart_numpy_identifier
#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#include <numpy/arrayobject.h>

#include <stdbool.h>
#include <complex.h>

#include "bart_embed_api.h"

#include "misc/debug.h"
#include "misc/misc.h"
#include "misc/mmio.h"
#include "misc/mmiocc.hh"

#ifndef DIMS
#  define DIMS 16
#endif

#define DP_UNSET -1

/* ========================================================================== */

struct error_jumper_s {
     bool initialized;
     jmp_buf buf;
};

extern struct error_jumper_s error_jumper;

/* -------------------------------------------------------------------------- */

struct disk_cfl_data_s {
     long D;
     long dims[DIMS];
     const _Complex float* data;
     struct disk_cfl_data_s* prev;
};
static struct disk_cfl_data_s* disk_cfl_data = NULL;

/* ========================================================================== */

extern int   bart_command(int size, char* out, int argc, char* argv[]);
extern _Bool register_mem_cfl_python(const char* name, PyArrayObject* npy_data);

/* Docstrings */
#include "python/pyBART_docstrings.c"

/* Available functions */
static PyObject* call_bart(PyObject *self, PyObject *args);
static PyObject* cleanup_memory(PyObject *self, PyObject *args);
static PyObject* load_cfl_python(PyObject* self, PyObject* args);
static PyObject* register_python_memory(PyObject *self, PyObject *args);
static PyObject* get_debug_level(PyObject *self, PyObject *args);
static PyObject* set_debug_level(PyObject *self, PyObject *args);
@PYBART_FUNCTION_PROTOTYPE@

/* ========================================================================== */

struct module_state {
     PyObject *error;
};

#if PY_MAJOR_VERSION >= 3
#define GETSTATE(m) ((struct module_state*)PyModule_GetState(m))
#else
#define GETSTATE(m) (&_state)
static struct module_state _state;
#endif /* PY_MAJOR_VERSION >= 3 */

static PyObject *
error_out(PyObject *m) {
    struct module_state *st = GETSTATE(m);
    PyErr_SetString(st->error, "something bad happened");
    return NULL;
}

/* ========================================================================== */

static PyMethodDef module_methods[] = {
     {"bart", call_bart, METH_VARARGS, call_bart_docstring},
     {"cleanup_memory", cleanup_memory, METH_NOARGS, cleanup_memory_docstring},
     {"load_cfl", load_cfl_python, METH_VARARGS, load_cfl_python_docstring},
     {"register_memory", register_python_memory, METH_VARARGS, register_python_memory_docstring},
     {"get_debug_level", get_debug_level, METH_NOARGS, get_debug_level_docstring},
     {"set_debug_level", set_debug_level, METH_O, set_debug_level_docstring},
     @PYBART_COMMANDS_MODULE_METHODS@
     {NULL, NULL, 0, NULL}
};

/* -------------------------------------------------------------------------- */

#define ADD_PYTHON_CONSTANT(name)				\
     if (PyModule_AddIntConstant(module, #name, name)) {	\
	  INITERROR;						\
     }

#if PY_MAJOR_VERSION >= 3
static int pyBART_traverse(PyObject *m, visitproc visit, void *arg) {
    Py_VISIT(GETSTATE(m)->error);
    return 0;
}

static int pyBART_clear(PyObject *m) {
     Py_CLEAR(GETSTATE(m)->error);
     return 0;
}

static struct PyModuleDef pyBART_definition = {
     PyModuleDef_HEAD_INIT,
     pyBART_module_name,
     pyBART_module_doc,
     sizeof(struct module_state),
     module_methods,
     NULL,
     pyBART_traverse,
     pyBART_clear,
     NULL
};

#  define INITERROR return NULL

PyObject* PyInit_pyBART(void)
#else
#  define INITERROR return
     
PyMODINIT_FUNC initpyBART(void)
#endif /* PY_MAJOR_VERSION >= 3 */
{
#if PY_MAJOR_VERSION >= 3
     PyObject *module = PyModule_Create(&pyBART_definition);
#else
     PyObject *module = Py_InitModule3("pyBART",
				       module_methods,
				       module_docstring);
#endif /* PY_MAJOR_VERSION >= 3 */

     if (module == NULL) {
	  INITERROR;
     }

     ADD_PYTHON_CONSTANT(DP_ERROR);
     ADD_PYTHON_CONSTANT(DP_WARN);
     ADD_PYTHON_CONSTANT(DP_INFO);
     ADD_PYTHON_CONSTANT(DP_DEBUG1);
     ADD_PYTHON_CONSTANT(DP_DEBUG2);
     ADD_PYTHON_CONSTANT(DP_DEBUG3);
     ADD_PYTHON_CONSTANT(DP_DEBUG4);
     ADD_PYTHON_CONSTANT(DP_TRACE);
     ADD_PYTHON_CONSTANT(DP_ALL);
     ADD_PYTHON_CONSTANT(DP_UNSET);
     
     struct module_state *st = GETSTATE(module);

     st->error = PyErr_NewException("pyBART.Error", NULL, NULL);
     if (st->error == NULL) {
	  Py_DECREF(module);
	  INITERROR;
     }

     /* Load `numpy` functionality. */
     import_array();

#if PY_MAJOR_VERSION >= 3
     return module;
#endif
}

#undef ADD_PYTHON_CONSTANT
#undef INITERROR

/* ========================================================================== */

PyObject* call_submain(const char* subcommand, const char* cmdline_in)
{
     enum { MAX_ARGS = 256 };
     char cmdline[1024] = { '\0' };
     char output[512] = { '\0' };

     snprintf(cmdline, 1024, "%s %s", subcommand, cmdline_in);

     // tokenize the command string into argc/argv (basic, hopefully enough)
     int argc = 0;
     char *argv[MAX_ARGS];
     char *argvv[MAX_ARGS];

     char *p2 = strtok(cmdline, " ");
     while (p2 && argc < MAX_ARGS-1)
     {
	  argv[argc++] = p2;
	  p2 = strtok(0, " ");
     }
     argv[argc] = 0;

     int ret = bart_command(512, output, argc, argv); // execute bart

     if (strlen(output) > 0) {
#if PY_MAJOR_VERSION >= 3
	  return PyUnicode_FromString(output);
#else
	  return PyString_FromString(output);
#endif /* PY_MAJOR_VERSION >= 3 */
     }
     else {
	  if (PyErr_Occurred()) {
	       return NULL;
	  }
	  else {
#if PY_MAJOR_VERSION >= 3
	       return PyLong_FromLong(ret);
#else
	       return PyInt_FromLong(ret);
#endif /* PY_MAJOR_VERSION >= 3 */
	  }
     }
}

/* ========================================================================== */

PyObject* call_bart(PyObject *self, PyObject *args)
{
     char* cmdline = NULL;

     if (!PyArg_ParseTuple(args, "s", &cmdline)) {
	  Py_RETURN_NONE;
     }

     return call_submain("", cmdline);
}

/* ========================================================================== */

PyObject* register_python_memory(PyObject *self, PyObject *args)
{
     char* name = NULL;
     PyObject* data = NULL;
     if (!PyArg_ParseTuple(args, "sO", &name, &data)) {
	  PyErr_SetString(PyExc_RuntimeError,
			  "failed to parse input arguments");
	  return NULL;
     }

     PyArrayObject* npy_data = (PyArrayObject*)(data);

     if (name == NULL) {
	  PyErr_SetString(PyExc_RuntimeError,
			  "name == NULL");
	  return NULL;
     }

#ifndef MEMONLY_CFL
     char* ext = strrchr(name, '.');
     if (ext == NULL || strncmp(ext, ".mem", strlen(ext)) != 0) {
	  return PyErr_Format(PyExc_RuntimeError,
			      "Name '%s' (%s) does not have the .mem extension,"
			      " but pyBART was not compiled with -DMEMONLY_CFL"
			      "(CMake option: BART_MEMONLY_CFL). "
			      "Your in-memory CFL file will be unreachable!",
			      name, ext);
     }
#endif /* !MEMONLY_CFL */

     if (npy_data == NULL) {
	  PyErr_SetString(PyExc_RuntimeError,
			  "npy_data == NULL");
	  return NULL;
     }

     if (!PyArray_Check(npy_data)) {
	  PyErr_SetString(PyExc_TypeError,
			  "npy_data is not of type numpy.ndarray");
	  return NULL;
     }

     if (PyArray_DESCR(npy_data)->type_num != NPY_CFLOAT) {
	  PyErr_SetString(PyExc_TypeError,
			  "npy_data must be of type complex float "
			  "(numpy.complex64)");
	  return NULL;
     }
     
     // ------------------------------------------------------------------------

     error_jumper.initialized = 1;
     if (setjmp(error_jumper.buf) == 0) {
	  if (register_mem_cfl_python(name, npy_data)) {
	       Py_RETURN_NONE;
	  }
	  else {
	       return NULL;
	  }
     }
     else {
	  if (PyErr_Occurred() != NULL) {
	       return NULL;
	  }
	  else {
	       Py_RETURN_NONE;
	  }
     }
}

/* ========================================================================== */

static void register_disk_cfl(unsigned int D,
			      const long dims[__VLA(D)],
			      const _Complex float* data)
{
     PTR_ALLOC(struct disk_cfl_data_s, new_data);

     new_data->D = D;
     memcpy(new_data->dims, dims, D * sizeof(long));
     new_data->data = data;
     new_data->prev = disk_cfl_data;

     disk_cfl_data = PTR_PASS(new_data);
}

void disk_cfl_cleanup(void)
{
     struct disk_cfl_data_s* tmp = NULL;
     while (NULL != disk_cfl_data) {
	  // Unmap memory
	  unmap_cfl(disk_cfl_data->D,
		    disk_cfl_data->dims,
		    disk_cfl_data->data);

	  // Cleanup memory
	  tmp = disk_cfl_data;
	  disk_cfl_data = disk_cfl_data->prev;
	  xfree(tmp);
     }
}

/* -------------------------------------------------------------------------- */

PyObject* load_cfl_python(PyObject* self, PyObject* args)
{
     char* name = NULL;
     if (!PyArg_ParseTuple(args, "s", &name)) {
	  PyErr_SetString(PyExc_RuntimeError,
			  "failed to parse input arguments");
	  return NULL;
     }

     error_jumper.initialized = 1;
     if (setjmp(error_jumper.buf) == 0) {
	  long dims[DIMS] = {0};
	  void* data = load_cfl(name, DIMS, dims);

	  if (data == NULL) {
	       PyErr_SetString(PyExc_RuntimeError,
			       "failed loading cfl file");
	       return NULL;	  
	  }

	  if (!is_mem_cfl(data)) {
	       register_disk_cfl(DIMS, dims, data);
	  }

	  npy_intp pydims[DIMS] = {0};
	  for (unsigned int i = 0; i < DIMS; ++i) {
	       pydims[i] = dims[i];
	  }

	  return PyArray_New(&PyArray_Type,
			     DIMS, pydims,
			     NPY_CFLOAT,
			     NULL, /* strides */
			     data,
			     sizeof(complex float),
			     NPY_ARRAY_CARRAY_RO,
			     NULL /* obj */);
     }
     else {
	  return NULL;
     }
}

/* ========================================================================== */

PyObject* cleanup_memory(PyObject* self, PyObject* args)
{
     deallocate_all_mem_cfl();
     disk_cfl_cleanup();
     
     Py_RETURN_NONE;
}

/* ========================================================================== */

#define IF_LEVEL_IS(name)					\
     if (debug_level == name) {					\
	  constant = PyDict_GetItemString(module_dict, #name);	\
     }

PyObject* get_debug_level(PyObject* self, PyObject* args)
{
    PyObject* module_dict = PyModule_GetDict(self);
    PyObject* constant = NULL;
    
    IF_LEVEL_IS(DP_ERROR)
    else IF_LEVEL_IS(DP_INFO)
    else IF_LEVEL_IS(DP_DEBUG1)
    else IF_LEVEL_IS(DP_DEBUG2)
    else IF_LEVEL_IS(DP_DEBUG3)
    else IF_LEVEL_IS(DP_DEBUG4)
    else IF_LEVEL_IS(DP_TRACE)
    else IF_LEVEL_IS(DP_ALL)
    else {
        constant = PyDict_GetItemString(module_dict, "DP_UNSET");
    }
    
    Py_INCREF(constant);
    return constant;
}

#undef IF_LEVEL_IS

/* -------------------------------------------------------------------------- */

PyObject* set_debug_level(PyObject* self, PyObject* param)
{
     int level = DP_UNSET;
     
     if (PyLong_Check(param)) {
	  level = PyLong_AsLong(param);
	  if (PyErr_Occurred()) {
	       return NULL;	  
	  }
     }
#if PY_MAJOR_VERSION == 2
     else if (PyInt_Check(param)) {
	  level = PyInt_AsLong(param);
	  if (PyErr_Occurred()) {
	       return NULL;	  
	  }
     }
#endif /* PY_MAJOR_VERSION == 2 */
     else if (PyFloat_Check(param)) {
	  double d = PyFloat_AsDouble(param);
	  if (PyErr_Occurred()) {
	       return NULL;	  
	  }

	  level = d;
	  if (level != d) {
	       PyErr_SetString(PyExc_RuntimeError,
			       "Cannot have decimal debug level");
	       return NULL;
	  }
     }
     else {
	  char buf[10] = { '\0' };
	  char* str = NULL;
	  
#if PY_MAJOR_VERSION >= 3
	  if (PyUnicode_Check(param)) {
#if PY_MINOR_VERSION >= 2
	       PyObject* tmp;
	       wchar_t* wstr = PyUnicode_AsWideCharString(param, NULL);
	       if (wstr == NULL) {
		    fprintf(stderr,
			    "ERROR: getting string from Python object\n");
		    return NULL;
	       }
	       wcstombs(buf, wstr, sizeof(buf)/sizeof(char));
	       str = buf;
	       PyMem_Free(wstr);
#else
	       // NB: not really tested...
	       str = PyUnicode_AS_DATA(param);
#endif /* PY_MINOR_VERSION >= 2 */
	  }
#else
	  if (PyString_Check(param)) {
	       str = PyString_AsString(param);	       
	  }
#endif /* PY_MAJOR_VERSION >= 3 */
	  else {
	       return PyErr_Format(PyExc_RuntimeError,
				   "Input argument has unsupported type: %s",
				   param->ob_type->tp_name);
	  }
	  
	  if (PyErr_Occurred() || str == NULL) {
	       fprintf(stderr,
		       "ERROR: something went wrong!\n");
	       return NULL;
	  }
	  else {
	       
#define IF_STR_IS(name) if (strcmp(str, #name) == 0) { level = name; }
	       
	       IF_STR_IS(DP_ERROR)
	       else IF_STR_IS(DP_WARN)
	       else IF_STR_IS(DP_INFO)
	       else IF_STR_IS(DP_DEBUG1)
	       else IF_STR_IS(DP_DEBUG2)
	       else IF_STR_IS(DP_DEBUG3)
	       else IF_STR_IS(DP_DEBUG4)
	       else IF_STR_IS(DP_TRACE)
	       else IF_STR_IS(DP_ALL)
	       else IF_STR_IS(DP_UNSET)
	       else {
		    return PyErr_Format(PyExc_RuntimeError,
					"String %s is not a valid debug level",
					str);
	       }

#undef IF_STR_IS
	  }
     }
     
     /* ----------------------------- */
     
#define ADD_CASE(name) case name: debug_level = name; break
     
     switch (level) {
	  ADD_CASE(DP_ERROR);
	  ADD_CASE(DP_WARN);
	  ADD_CASE(DP_INFO);
	  ADD_CASE(DP_DEBUG1);
	  ADD_CASE(DP_DEBUG2);
	  ADD_CASE(DP_DEBUG3);
	  ADD_CASE(DP_DEBUG4);
	  ADD_CASE(DP_TRACE);
	  ADD_CASE(DP_ALL);
	  ADD_CASE(DP_UNSET);
     default:
	  printf("WARNING: invalid value for debug level (%d),"
		 " setting level to DP_UNSET (%d)\n", level, DP_UNSET);
	  debug_level = DP_UNSET;
     }

#undef ADD_CASE

     Py_RETURN_NONE;
}

/* ========================================================================== */

@PYBART_COMMANDS_IMPLEMENTATION@
